from __future__ import annotations

"""Shared helpers for validating and filtering AI-generated tags."""

import re
from typing import Iterable

from app.repositories import tag_exclusions as tag_exclusions_repo

# Tags that have proven to be unhelpful in practice when generated by AI models.
# These values should be expressed as kebab-case slugs to match downstream usage.
# This is the default set, but additional exclusions can be configured via the admin UI.
UNHELPFUL_TAG_SLUGS: set[str] = {
    "json",
    "tag",
    "tags",
    "user-support",
    "syncro-software",
    "booking-appointment",
    "hawkinsit-solutions",
    "normal",
}


async def get_all_excluded_tags() -> set[str]:
    """Get all excluded tags from both the default set and database."""
    db_exclusions = await tag_exclusions_repo.get_excluded_tag_slugs()
    return UNHELPFUL_TAG_SLUGS | db_exclusions


def slugify_tag(value: str) -> str | None:
    """Convert raw tag text into a kebab-case slug."""

    if not value:
        return None
    lowered = value.lower()
    cleaned = re.sub(r"[^a-z0-9\s\-]+", "", lowered)
    cleaned = re.sub(r"\s+", "-", cleaned)
    cleaned = re.sub(r"-+", "-", cleaned).strip("-")
    if not cleaned:
        return None
    return cleaned[:48]


def _slug_body_length(slug: str) -> int:
    """Return the number of alphanumeric characters contained in a slug."""

    return sum(1 for char in slug if char.isalnum())


def is_helpful_slug(slug: str, excluded_tags: set[str] | None = None) -> bool:
    """Determine whether a slug represents a useful ticket tag.
    
    Args:
        slug: The tag slug to check
        excluded_tags: Optional set of excluded tags. If None, uses UNHELPFUL_TAG_SLUGS only.
    """

    if not slug:
        return False
    # Use provided exclusions or fall back to default set
    exclusion_set = excluded_tags if excluded_tags is not None else UNHELPFUL_TAG_SLUGS
    if slug in exclusion_set:
        return False
    # Check if any excluded word appears as a component within the tag
    # Split by hyphens to get individual words in the slug
    slug_words = slug.split("-")
    for word in slug_words:
        if word in exclusion_set:
            return False
    if _slug_body_length(slug) < 3:
        return False
    if slug.replace("-", "").isdigit():
        return False
    return True


def filter_helpful_slugs(tags: Iterable[str], excluded_tags: set[str] | None = None) -> list[str]:
    """Filter an iterable of slug strings down to helpful, unique tags.
    
    Args:
        tags: Tags to filter
        excluded_tags: Optional set of excluded tags. If None, uses UNHELPFUL_TAG_SLUGS only.
    """

    filtered: list[str] = []
    seen: set[str] = set()
    for tag in tags:
        if not tag or not isinstance(tag, str):
            continue
        slug = tag.strip()
        if not slug:
            continue
        if not is_helpful_slug(slug, excluded_tags):
            continue
        if slug in seen:
            continue
        filtered.append(slug)
        seen.add(slug)
    return filtered


def filter_helpful_texts(tags: Iterable[str], excluded_tags: set[str] | None = None) -> list[str]:
    """Filter raw tag text values, preserving order and applying helpfulness rules.
    
    Args:
        tags: Tags to filter
        excluded_tags: Optional set of excluded tags. If None, uses UNHELPFUL_TAG_SLUGS only.
    """

    filtered: list[str] = []
    seen: set[str] = set()
    for tag in tags:
        if not tag or not isinstance(tag, str):
            continue
        normalised = re.sub(r"\s+", " ", tag.strip().lower())
        if not normalised:
            continue
        slug = slugify_tag(normalised)
        if slug is None or not is_helpful_slug(slug, excluded_tags):
            continue
        if slug in seen:
            continue
        filtered.append(normalised)
        seen.add(slug)
    return filtered
